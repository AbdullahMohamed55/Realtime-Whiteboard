#!/usr/bin/env node
/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('dum:server');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

var io = require('socket.io')(server);
//TODO USE A DB (reddis)
//NAIVE SOLUTION!
var roomArr = [];//num of users in each room
var roomHist = [];
//TODO add histroy of drawing & bckgnd settings
var drawHist = [];
var bckgnd = [];
var roomUrl = new Object();
// open socket conn whenever a new room is created
io.sockets.on("connection", newConnection);


//TODO emit url of a room when requseted

function newConnection(socket) {

    var addedUser = false;
    console.log("connected");
    io.clients(function(error, clients){
        if (error) throw error;
        console.log(clients);
    });
    // when the client emits 'add user', this listens and executes
    socket.on('addUser2Room', function (data) {
        if (addedUser) return;
        console.log("url coming");
        console.log(data.url);
        // search for roomurl if it exist
        var found = false;
        for(var val in roomUrl){
            if (roomUrl[val] == data.url){
                found = true;
            }
        }
        if(!found){
            var uuid = require('node-uuid');

            socket.emit("Token not found");
            // Generate a v1 (time-based) id
            var timeBasedID = uuid.v1(); // -> '6c84fb90-12c4-11e1-840d-7b25c5ee775a'

            // Generate a v4 (random) id
            var randomID = uuid.v4(); // -> '110ec58a-a0f2-4ac4-8393-c866d813b8d1'

            var url = randomID;  // or + timeBasedID

            //insert url and roomname
            data.url =url;
            roomUrl[data.roomname] = url;
        }


        // we store the username in the socket session for this client and this room
        console.log(data.username, " is joining room ", data.url);

        socket.join(data.url);

        socket.username = data.username;
        socket.roomname = data.roomname;
        socket.url = data.url;
        //user joins an existing room
        if(data.url in roomArr){
            roomArr[data.url] += 1;
            //supply new user with room history
            io.to(socket.id).emit('updateNewJoiner',roomHist[data.url]);
            console.log(drawHist[data.url]);
            // if(drawHist[data.url] != []){
                io.to(socket.id).emit('updateNewJoinerDraw',drawHist[data.url]);
            // }
            if(bckgnd[data.url] != []) {

                io.to(socket.id).emit('updateNewJoinerDrawBckgnd', bckgnd[data.url]);

            }
        }
        else{
            //init this room history
            roomHist[data.url] = [];
            drawHist[data.url] = [];
            bckgnd[data.url] = '';
            roomArr[data.url] = 1;

        }
        console.log(roomUrl);

        //console.log(roomArr[data.roomname]);

        //console.log(socket.rooms);

        //console.log(socket.roomname);
        //++numUsers;
        addedUser = true;



        // sending to all clients in room except sender
        socket.to(data.url).emit('user joined', {
            username: socket.username,
            numUsers: roomArr[socket.url]
        });
        console.log("URL bfore log"+data.url);
        io.in(data.url).emit('login', {
            numUsers: roomArr[socket.url],
            url : data.url

        });

    });

    // when the client emits 'new message', this listens and executes
    socket.on('new message', function (data) {
        // we tell the client to execute 'new message'
        roomHist[socket.url].push({username: socket.username,message: data,id:socket.id});
        //TODO make it socket.to
        io.in(socket.url).emit('new message', {
            username: socket.username,
            message: data,
            id : socket.id
        });
    });

    // when the client emits 'typing', we broadcast it to others
    socket.on('typing', function () {
        //console.log('typing');
        socket.to(socket.url).emit('typing', {
            username: socket.username
        });
    });

    // when the client emits 'stop typing', we broadcast it to others
    socket.on('stop typing', function () {
        //console.log('stopped typing');
        socket.to(socket.url).emit('stop typing', {
            username: socket.username
        });
    });

    //DRAWING STUFF
    socket.on('drawCircle',
        function(data) {
            // Data comes in as whatever was sent, including objects
            //console.log("Received data: " + data);

            // Send it to all other clients
            socket.to(socket.url).emit('drawCircle', data);
        }
    );


    socket.on('changeBackground',
        function(data) {
            // Data comes in as whatever was sent, including objects
            //console.log("Received data: " + data);

            bckgnd[socket.url] = data;
            // Send it to all other clients
            socket.to(socket.url).emit('changeBackground', data);
        }
    );

    socket.on('brush1',
        function(data) {
            // Data comes in as whatever was sent, including objects
            //console.log("Received data1: " + data);
            // Send it to all other clients
            //drawHist[socket.url].push(data);
            socket.to(socket.url).emit('brush1', data);
        }
    );

    socket.on('brush2',
        function(data) {
            // Data comes in as whatever was sent, including objects
            //console.log("Received data2: " + data);
            // Send it to all other clients
            socket.to(socket.url).emit('brush2', data);
        }
    );

    socket.on('undo',
        function() {
            // Data comes in as whatever was sent, including objects
            //console.log("Received undo request: " + data);
            // Send it to all other clients
            if(typeof drawHist[socket.url] != 'undefined' || drawHist[socket.url] != null ) {

                // console.log("drawHist client:" + drawHist[socket.url][0][0] + "|| Paths: " + drawHist[socket.url][0][1]);
                // console.log("drawHist client:" + drawHist[socket.url][1][0] + "|| Paths: " + drawHist[socket.url][1][1]);
                // console.log("1st path in 1st client: " + drawHist[socket.url][0]);
                // console.log("2nd path in 1st client: " + drawHist[socket.url][1]); // I want to delete(pop) specificlly this from drawHist!!
                // console.log("1st path in 2nd client: " + drawHist[socket.url][2]);

                //Dolaaaaaaaaaaa3!
                // console.log("clientID in drawing history: " + drawHist[socket.url][0][0]);
                console.log("clientID in sever side: " + socket.id);

                var detectedUser = false;
                var myIdx = -1;
                console.log("drawing history size: " + drawHist[socket.url].length);
                for(var i=0; i<drawHist[socket.url].length; i++){

                    console.log("loop #" + i);
                    console.log("current userID in history: " + drawHist[socket.url][i][0]);

                    if( drawHist[socket.url][i][0] == socket.id){
                        detectedUser = true;
                        console.log("User detected: " + detectedUser);
                    }
                    //toggeled user
                    else {
                        console.log("User toggeled: ");
                        if(detectedUser == true){
                            myIdx = i-1;
                            break;
                            console.log("My Index: " + myIdx);

                        }
                    }
                    //no one else drew anything in drawingHist
                    if(detectedUser == true && i == drawHist[socket.url].length-1 ){
                        console.log("No else Users");
                        myIdx = i;
                        break;
                        console.log("My Index: " + myIdx);
                    }

                        }

                console.log("detected idx: " + myIdx);
                console.log("DrawHisht Before undo: " + drawHist[socket.url]);

                // drawHist[socket.url][myIdx].pop(); removing id
                // drawHist[socket.url][myIdx].pop(); removing paths
                if(myIdx != -1) {
                    drawHist[socket.url].splice(myIdx, 1);
                }

                console.log("DrawHisht after undo: " + drawHist[socket.url]);


            }

            //drawHist[socket.url];

            // for(x in drawHist[socket.url][socket.id]){
            //     if(x == socket.id){
            //         drawHist[socket.url][socket.id].pop();
            //     }
            // }



            // for (var i = 0; i < data.length; i++) {
            //
            //     var client = data[i][0];
            //     var currentData = data[i][1];
            //
            //     console.log("client: " + client);
            //     console.log("currentData: " +currentData);
            //
            //     var histPath = new Path();
            //     histPath.strokeColor = currentData[0].Dcolor;
            //     histPath.strokeWidth = currentData[0].Dsize;
            //
            //     for (var j = 0; j < currentData.length; j++) {
            //
            //         histPath.add(new Point(currentData[j].pnt[1], currentData[j].pnt[2]));
            //     }
            //
            //     if(!paths3Holder[client]) {
            //         paths3Holder[client] = new Array();
            //     }
            //     paths3Holder[client].push(histPath);
            //
            // }


            socket.to(socket.url).emit('undo', socket.id);
        }
    );

    socket.on('clear',
        function(data) {
            drawHist[socket.url] =[];
            socket.to(socket.url).emit('clear', data);
        }
    );

    socket.on('mouse_up',
        function(data) {
            //console.log("Server Received History: " + data[0][0].Dcolor + " " + data[0][0].Dsize + " " +data[0][0].pnt);
            // if(!drawHist[socket.url]){
            //     drawHist[socket.url] = [];
            // }
            //drawHist[socket.url].push(socket.id);

            if(!drawHist[socket.url])
            {drawHist[socket.url] = new Array();}

            // if(!drawHist[socket.url][socket.id])
            // {drawHist[socket.url][socket.id] = new Array();}

            // drawHist[socket.url][socket.id].push(data);
            drawHist[socket.url].push([socket.id, data]);
            console.log("Drawing History: " + drawHist[socket.url]);
            socket.to(socket.url).emit('mouse_up',socket.id);
        }
    );

    // when the user disconnects.. perform this
    socket.on('disconnect', function () {
        console.log("disconnected");
        io.clients(function(error, clients){
            if (error) throw error;
            console.log("MEx: ", clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]
        });

        if (addedUser) {

            if(--roomArr[socket.url] == 0){
                delete roomArr[socket.url];
                delete roomHist[socket.url];
                delete drawHist[socket.url];
            }
            console.log("Rooms left : " , roomArr);
            io.in(socket.url).emit('login', {
                numUsers: roomArr[socket.url],
                url : socket.url

            });
            console.log(socket.username, " has left room ", socket.url);
            // echo globally that this client has left
            socket.leave(socket.url);
            //socket.leaveAll();
            socket.to(socket.url).emit('user left', {
                username: socket.username,
                numUsers: roomArr[socket.url]
            });
        }
    });
}

///////////////////////////////////////////////////////
/*
 //console.log("new connection  " + socket.id);


 //reloadUsers(); // Send the count to all the users

 socket.on('message', function(msg,usr){
 console.log("New message:", msg,"From : " ,usr);
 //send it to all other users
 //socket.broadcast.emit('chat message', msg);
 //send it to all including me!
 io.sockets.emit('message', msg,usr);
 });
 socket.on('disconnect', function() {
 console.log("Client has disconnected");
 users -= 1;
 reloadUsers();

 });
 }
 function reloadUsers() { // Send the count of the users to all
 io.sockets.emit('nbUsers', {"nb": users});
 }
 */
/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    var port = parseInt(val, 10);

    if (isNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    var bind = typeof port === 'string'
        ? 'Pipe ' + port
        : 'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    var addr = server.address();
    var bind = typeof addr === 'string'
        ? 'pipe ' + addr
        : 'port ' + addr.port;
    debug('Listening on ' + bind);
}